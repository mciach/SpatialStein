import numpy as np
from matplotlib import pyplot as plt
from .data_preprocessing import get_msi_shape

def generate_total_spectrum(msi, mass_axis, mask=None, normalize_spectra=True):
    """
    Return a spectrum generated by summing all pixels in the data set.
    The data set needs to be in profile mode! Each pixel spectrum gets
    interpolated in the points of mass_axis.
    Spectra are normalized before interpolation. 
    If mask is supplied, it needs to be a binary or boolean array
    with the same shape as the data set.
    Pixels corresponding to value zero or False are ignored.
    If mask is used, then the data set needs to be xy-indexed starting
    from 1 (i.e. (1, 1) is the bottom-left corner; default e.g. for ImzMLParser),
    while segment_mask needs to be array-indexed (i.e. segment_mask[0, 0]
    is the bottom-left corner; default e.g. for plt.imshow).
    
    """
    total_intensity = np.zeros(mass_axis.shape)
    skipped = 0
    for idx, (xcoord,ycoord,zcoord) in enumerate(msi.coordinates):
        if mask is not None and not mask[ycoord-1, xcoord-1]:
            skipped += 1
            continue
        mz, intsy = msi.getspectrum(idx)
        if normalize_spectra:
            intsy = intsy / np.trapz(intsy, mz)
        intsy = np.interp(mass_axis, mz, intsy)
        total_intensity += intsy
    #print('skipped', skipped)
    return total_intensity

def _profile_TIC_array(msi):
    shape = get_msi_shape(msi)
    TIC_array = np.zeros(shape)
    for idx, (xcoord,ycoord,zcoord) in enumerate(msi.coordinates):
        mz, intsy = msi.getspectrum(idx)
        mz, intsy = np.array(mz), np.array(intsy)
        tic = np.trapz(intsy, mz)  
        TIC_array[ycoord-1, xcoord-1] = tic
    return TIC_array

def _centroided_TIC_array(msi):
    shape = get_msi_shape(msi)
    TIC_array = np.zeros(shape)
    for idx, (xcoord,ycoord,zcoord) in enumerate(msi.coordinates):
        mz, intsy = msi.getspectrum(idx)
        TIC_array[ycoord-1, xcoord-1] = np.sum(intsy)
    return TIC_array

def calculate_TIC_array(msi, is_profile_mode):
    """
    Calculates the Total Ion Current for an msi data set.
    """
    if is_profile_mode:
        return _profile_TIC_array(msi)
    else:
        return _centroided_TIC_array(msi)

def generate_summary_spectrum(msi, TIC_array, mass_axis):
    """
    Calculates a summary spectrum and returns as a numpy array.
    A summary spectrum contains the average spectrum, the standard
    deviation spectrum, the skyline (maximum signal) spectrum and the
    minimum signal spectrum.
    The data needs to be in profile mode!
    """
    intensity_mean = np.zeros(len(mass_axis))
    intensity_sd = np.zeros(len(mass_axis))
    intensity_min = np.zeros(len(mass_axis)) + np.inf
    intensity_max = np.zeros(len(mass_axis))
    for idx, (xcoord,ycoord,zcoord) in enumerate(msi.coordinates):
        if not idx % 10000:
            print('Processing pixel number', idx)
        mz, intsy = msi.getspectrum(idx)
        mz, intsy = np.array(mz), np.array(intsy)
        tic = TIC_array[ycoord-1, xcoord-1] 
        # Resample the intensity measurements in the points of the common mass axis
        # through a linear interpolation. This will also restrict our spectrum to the region of interest.
        intsy = np.interp(mass_axis, mz, intsy)
        assert all(intsy) >= 0        
        # Normalize the intensity by the total ion current 
        # (so that the signal integrates to unity)
        intsy /= tic 
        intensity_mean += intsy
        intensity_max = np.maximum(intensity_max, intsy)
        intensity_min = np.minimum(intensity_min, intsy)
        intensity_sd += intsy**2  
    # the idx variable now stores the index of the last pixel,
    # so it's equal to the number of pixels minus one
    intensity_mean /= (idx+1)
    intensity_sd /= (idx+1)
    intensity_sd -= intensity_mean**2
    assert all(intensity_sd >= 0)
    intensity_sd **= 0.5
    summary_spectrum = np.zeros((len(mass_axis), 4))
    summary_spectrum[:, 0] = intensity_mean
    summary_spectrum[:, 1] = intensity_sd
    summary_spectrum[:, 2] = intensity_min
    summary_spectrum[:, 3] = intensity_max
    return summary_spectrum

def plot_summary_spectrum(mass_axis, summary_spectrum_array, figsize=(8,4),
                          plot_title='Summary spectrum'):
    """
    Plots a spectrum showing the average intensity across the image
    along with the intensity's standard deviation, minimum, and maximum value.
    summary_spectrum_array is an array with four columns corresponding
    to the average, sd, min and max value.
    The number of rows in summary_spectrum_array needs to be equal to the length of mass_axis. 
    """
    assert np.all(summary_spectrum_array[:,0] >= 0), 'Intensity needs to be non-negative!'
    assert np.all(summary_spectrum_array[:,1] >= 0), 'Standard deviation needs to be non-negative!'
    assert np.all(summary_spectrum_array[:,2] <= summary_spectrum_array[:,3]), 'The minimum signal cannot be greater than the maximum!'
    av = summary_spectrum_array[:,0]
    sd = summary_spectrum_array[:,1]
    mn = summary_spectrum_array[:,2]
    mx = summary_spectrum_array[:,3]
    plt.figure(figsize=figsize)
    plt.title(plot_title)
    p1=plt.fill_between(mass_axis, av-sd, av+sd, alpha=1, color='orange')
    p2=plt.fill_between(mass_axis, av-3*sd, av+3*sd, alpha=0.2, color='orange')
    p3=plt.plot(mass_axis, av)
    p4=plt.plot(mass_axis, mx, 'k', alpha=0.4)
    p5=plt.plot(mass_axis, mn, 'k', alpha=0.4)
    plt.legend(['$\mu$', 'min', 'max', '$\mu \pm \sigma$', '$\mu \pm 3\sigma$'])
    plt.show()


def profile_ion_image(msi, mz, normalize=True):
    """
    Returns an array of signal intensities at a given mz point from an MSI
    data set with spectra in profile mode.
    Uses a linear interpolation.
    Optionally, each pixel spectrum can be normalized to unit area under curve. 
    """
    max_coord = max(msi.coordinates)[:2]
    min_coord = min(msi.coordinates)[:2]
    image_shape = (max_coord[1] - min_coord[1] + 1, max_coord[0] - min_coord[0] + 1)
    #print(image_shape)
    ion_image = np.zeros(image_shape)
    for idx, (xcoord,ycoord,zcoord) in enumerate(msi.coordinates):
        mz_array, intsy =  msi.getspectrum(idx)
        if normalize:
            intsy = intsy / np.trapz(intsy, mz_array)
        ion_image[ycoord-1,xcoord-1] = np.interp(mz, mz_array, intsy)
    return ion_image


def centroided_ion_image(msi, mz_list, delta=0.01, normalize=True, verbose=False):
    """
    Returns an array of signal intensities at a given mz point from an MSI
    data set with spectra in centroided mode.
    Uses a binary search to find the peak closest to mz, and then checks if it's within the mass
    accuracy given by the delta parameter (in Daltons).
    """
    max_coord = max(msi.coordinates)[:2]
    min_coord = min(msi.coordinates)[:2]
    image_shape = (max_coord[1] - min_coord[1] + 1, max_coord[0] - min_coord[0] + 1)
    #print(image_shape)
    ion_images = np.zeros(image_shape + (len(mz_list),))
    distance_images = np.zeros(image_shape + (len(mz_list),)) + np.inf
    for idx, (xcoord,ycoord,zcoord) in enumerate(msi.coordinates):
        if verbose:
            if not idx % 10000:
                print(idx)
        mz_array, intsy =  msi.getspectrum(idx)
        if normalize:
            intsy = intsy / np.sum(intsy)
        assert all(nx>pr for nx, pr in zip(mz_array[1:], mz_array)), 'MZ array is not sorted'
        nbh_list = np.searchsorted(mz_array, mz_list)
        for mz_id, nbh in enumerate(nbh_list):
            mz = mz_list[mz_id]
            if nbh==0:
                if abs(mz - mz_array[0]) <= delta:
                    ion_images[ycoord-1, xcoord-1, mz_id] = intsy[0]
                    distance_images[ycoord-1, xcoord-1, mz_id] = mz - mz_array[0]
            elif nbh==len(mz_array):
                if abs(mz - mz_array[-1]) <= delta:
                    ion_images[ycoord-1, xcoord-1, mz_id] = intsy[-1]
                    distance_images[ycoord-1, xcoord-1, mz_id] = mz - mz_array[-1]
            else:
                l, r = mz_array[nbh-1], mz_array[nbh]
                if mz - l < r - mz:
                    # left neighbour is the closest one; update the closest neighbour index
                    nbh -= 1
                if abs(mz - mz_array[nbh]) <= delta:
                    ion_images[ycoord-1, xcoord-1, mz_id] = intsy[nbh]
                    distance_images[ycoord-1, xcoord-1, mz_id] = mz - mz_array[nbh]
    return (ion_images, distance_images)


def _check_pixel(idx, mz_array, intsy, mz, delta, normalize):
    signal = 0
    dist = 0
    if normalize:
        intsy = intsy / np.sum(intsy)
    assert all(nx>pr for nx, pr in zip(mz_array[1:], mz_array)), 'MZ array is not sorted'
    nbh = np.searchsorted(mz_array, mz)
    if nbh==0:
        if abs(mz - mz_array[0]) <= delta:
            signal = intsy[0]
            dist = mz - mz_array[0]
    elif nbh==len(mz_array):
        if abs(mz - mz_array[-1]) <= delta:
            signal = intsy[-1]
            dist = mz - mz_array[-1]
    else:
        l, r = mz_array[nbh-1], mz_array[nbh]
        if mz - l < r - mz:
            # left neighbour is the closest one; update the closest neighbour index
            nbh -= 1
        if abs(mz - mz_array[nbh]) <= delta:
            signal = intsy[nbh]
            dist = mz - mz_array[nbh]
    return(idx, signal, dist)
